<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<title>3D Particle Hand Control</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #0f172a;
    font-family: system-ui, sans-serif;
  }
  #ui {
    position: fixed;
    top: 16px;
    left: 16px;
    background: rgba(15, 23, 42, 0.85);
    padding: 12px 16px;
    border-radius: 12px;
    color: #fff;
    backdrop-filter: blur(10px);
  }
  input[type="color"] {
    border: none;
    width: 40px;
    height: 40px;
    cursor: pointer;
  }
  video {
    display: none;
  }
</style>
</head>

<body>
<div id="ui">
  <div>ðŸŽ¨ MÃ u háº¡t</div>
  <input type="color" id="colorPicker" value="#00ffff">
</div>

<video id="video" autoplay playsinline></video>

<!-- THREE.JS -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<!-- MEDIAPIPE -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ================= THREE SETUP ================= */
const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000)
camera.position.z = 120

const renderer = new THREE.WebGLRenderer({ antialias: true })
renderer.setSize(window.innerWidth, window.innerHeight)
document.body.appendChild(renderer.domElement)

/* ================= PARTICLES ================= */
const COUNT = 2000
const geometry = new THREE.BufferGeometry()
const positions = new Float32Array(COUNT * 3)
const basePositions = []

const radius = 30
for (let i = 0; i < COUNT; i++) {
  const phi = Math.acos(2 * Math.random() - 1)
  const theta = Math.random() * Math.PI * 2
  const x = radius * Math.sin(phi) * Math.cos(theta)
  const y = radius * Math.sin(phi) * Math.sin(theta)
  const z = radius * Math.cos(phi)
  positions.set([x,y,z], i*3)
  basePositions.push(new THREE.Vector3(x,y,z))
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))

const material = new THREE.PointsMaterial({
  color: 0x00ffff,
  size: 1.8
})

const particles = new THREE.Points(geometry, material)
scene.add(particles)

/* ================= COLOR PICKER ================= */
document.getElementById("colorPicker").addEventListener("input", e => {
  material.color.set(e.target.value)
})

/* ================= HAND TRACKING ================= */
const video = document.getElementById("video")
let scaleTarget = 1

const hands = new Hands({
  locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
})

hands.setOptions({
  maxNumHands: 2,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
})

hands.onResults(results => {
  if (results.multiHandLandmarks?.length === 2) {
    const h1 = results.multiHandLandmarks[0][9]
    const h2 = results.multiHandLandmarks[1][9]
    const dx = h1.x - h2.x
    const dy = h1.y - h2.y
    const distance = Math.sqrt(dx*dx + dy*dy)
    scaleTarget = THREE.MathUtils.clamp(distance * 6, 0.5, 3)
  }
})

const cam = new Camera(video, {
  onFrame: async () => await hands.send({ image: video }),
  width: 640,
  height: 480
})
cam.start()

/* ================= ANIMATION ================= */
function animate() {
  requestAnimationFrame(animate)

  const pos = geometry.attributes.position.array
  for (let i = 0; i < COUNT; i++) {
    pos[i*3]     += (basePositions[i].x * scaleTarget - pos[i*3]) * 0.08
    pos[i*3 + 1] += (basePositions[i].y * scaleTarget - pos[i*3 + 1]) * 0.08
    pos[i*3 + 2] += (basePositions[i].z * scaleTarget - pos[i*3 + 2]) * 0.08
  }
  geometry.attributes.position.needsUpdate = true

  particles.rotation.y += 0.002
  renderer.render(scene, camera)
}

animate()

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(window.innerWidth, window.innerHeight)
})
</script>
</body>
</html>